###################################################################
#                            Melissa                              #
#-----------------------------------------------------------------#
#   COPYRIGHT (C) 2017  by INRIA and EDF. ALL RIGHTS RESERVED.    #
#                                                                 #
# This source is covered by the BSD 3-Clause License.             #
# Refer to the  LICENCE file for further information.             #
#                                                                 #
#-----------------------------------------------------------------#
#  Original Contributors:                                         #
#    Theophile Terraz,                                            #
#    Bruno Raffin,                                                #
#    Alejandro Ribes,                                             #
#    Bertrand Iooss,                                              #
###################################################################


"""
    User defined options module
"""
import os
import time
import numpy as np
import subprocess
import getpass
import imp
import socket
import openturns as ot
#from matplotlib import pyplot as plt
#from matplotlib import cm
from string import Template
from shutil import copyfile
imp.load_source("melissa", "@CMAKE_INSTALL_PREFIX@/share/melissa/launcher/melissa.py")
import melissa

# These variables are only used in this file.
USERNAME = getpass.getuser()
BUILD_WITH_MPI = '@BUILD_WITH_MPI@'.upper()
BUILD_WITH_FLOWVR = '@BUILD_WITH_FLOWVR@'.upper()
EXECUTABLE='heatc'
NODES_SERVER = 2
NODES_GROUP = 1
WALLTIME_SERVER = 600
WALLTIME_SIMU = 300
WORKDIR = '@EXAMPLES_DIR@/heat_example/study_local/STATS'
NB_PARAM = 5

# The launch_server function to put in USER_FUNCTIONS['launch_server'].
# It takes a Server object as argument, and must set its job_id attribute.
# Here, we use the PID of the subprocess.
# The server object provides two important attributes:
#   path: the path to melissa_server executable
#   cmd_opt: the options set by the launcher to pass to the server.

def launch_server(server):
    if (not os.path.isdir(WORKDIR)):
        os.mkdir(WORKDIR)
    os.chdir(WORKDIR)
    print('mpirun ' + ' -n '+str(NODES_SERVER) + ' ' + server.path + '/melissa_server ' + server.cmd_opt + ' &')
    server.job_id = subprocess.Popen(('mpirun ' +
                                      ' -n '+str(NODES_SERVER) +
                                      '  ' + server.path +
                                      '/melissa_server ' +
                                      server.cmd_opt +
                                      ' &').split()).pid
    os.chdir(WORKDIR)

# The launch_group function to put in USER_FUNCTIONS['launch_group'].
# It is used to launch batches of simulations (or groups of simulation the case of Sobol' indices computation).
# It takes a Group object as argument, and must set the job ID of the group of simulations in the attribute job_id of the Group object.
# This object provides three important attributes:
#   simu_id:
#   rank
#   param_set
# We distinguish three kinds of groups:

# Once we have set the job IDs of our jobs, we can use it to define the fault tolerance functions. In our case, we will use the same function for the server and the simulations. It takes a `Job` object as argument, and sets its `status` attribute to 0 if it is waiting to be scheduled, 1 if it is currently running, or 2 if it is not running anymore. In your local machine, a job will never be have a 0 status, because it is launched immediately when `USER_FUNCTIONS['launch_group']` is called.

def launch_group(group):
    if (not os.path.isdir(WORKDIR+"/group"+str(group.rank))):
        os.mkdir(WORKDIR+"/group"+str(group.rank))
    os.chdir(WORKDIR+"/group"+str(group.rank))
    os.environ['MELISSA_SERVER_NODE_NAME'] = group.server_node_name

    if group.ml_stats['sobol_indices']:

        # Sobol group: In the case of Sobol' indices computation, all the simulations of a Sobol' group must be in the same job.
        # In that case, simu_id is a list of the simulation IDs inside the Sobol' group (the ones you will pass to melissa_init), and rank is the ID of the group.
        # param_set is a list of size group.nb_param + 2 of numpy arrays of size group.nb_param, corresponding to the sets of n parameters of the n+2 simulations in the Sobol' group.

        if BUILD_WITH_FLOWVR == 'ON' and STUDY_OPTIONS['coupling'] == 'MELISSA_COUPLING_FLOWVR':
            args = []
            for i, simu_id in enumerate(group.simu_id):
                args.append(str(simu_id)+" "+ str(group.coupling)+" "+' '.join(str(j) for j in group.param_set[i]))
            content = ""
            file=open("@EXAMPLES_DIR@/heat_example/study_local/scripts/flowvr_group.py", "r")
            content = Template(file.read()).substitute(args=str(args),
                               group_id=str(group.rank),
                               np_simu=str(int(NODES_GROUP)),
                               nb_param=str(group.nb_param),
                               executable='@EXAMPLES_DIR@/heat_example/solver/install/bin/'+EXECUTABLE)
            file.close()
            file=open("create_group"+str(group.rank)+".py", "w")
            file.write(content)
            file.close()
            os.system('python create_group'+str(group.rank)+'.py')
            group.job_id = subprocess.Popen('flowvr group'+str(group.rank), shell=True).pid
        else:
            os.environ['MELISSA_MASTER_NODE_NAME'] = socket.gethostname()
            command = 'mpirun '
            for i, simu_id in enumerate(group.simu_id):
                command += ' '.join(('-n',
                                     str(NODES_GROUP),
                                     '@EXAMPLES_DIR@/heat_example/solver/install/bin/'+EXECUTABLE,
                                     str(simu_id), str(group.coupling),
                                     ' '.join(str(j) for j in group.param_set[i]),
                                     ': '))
            print(command[:-2])
            group.job_id = subprocess.Popen(command[:-2].split()).pid

    else:

        # Batch of simulations: Multiple simulations are launched in the same job.
        # In that case, simu_id is a list of the simulation IDs of size STUDY_OPTIONS['batch_size'] (the ones you will pass to melissa_init in your solver), and rank is the ID of the group.
        # param_set is a list of size STUDY_OPTIONS['batch_size'] of numpy arrays of size group.nb_param.
        # The parameter STUDY_OPTIONS['sampling_size'] must be a multiple of STUDY_OPTIONS['batch_size'].

        command = 'mpirun '
        for i in range(group.size):
            command += ' '.join(('-n',
                                 str(NODES_GROUP),
                                 '@EXAMPLES_DIR@/heat_example/solver/install/bin/'+EXECUTABLE,
                                 str(group.simu_id[i]),
                                 str(group.coupling),
                                 ' '.join(str(j) for j in group.param_set[i]),
                                 ': '))
        print(command[:-2])
        os.environ['MELISSA_MASTER_NODE_NAME'] = socket.gethostname()
        group.job_id = subprocess.Popen(command[:-2].split()).pid

    os.chdir(WORKDIR)

def check_job(job):
    # Check the job state:
    # 0: not runing
    # 1: running
    # 2: not running anymore (finished or crashed)
    state = 0
    try:
        subprocess.check_output(["ps",str(job.job_id)])
        state = 1
    except:
        state = 2
    # we set the job_status attribute of the Job object. Group and Server objects inherite of Job.
    job.job_status = state

def check_load():
    # We only run one group at a time
    #time.sleep(1)
    time.sleep(1)
    try:
        out = str(subprocess.check_output(["pidof",EXECUTABLE])).split()
    except:
        return True
    if len(out) > 3:
        return False
    else:
        time.sleep(2)
        return True

def kill_job(job):
    os.system('kill '+str(job.job_id))

def param_distribution():
    param0 = ot.Uniform(0.0, 1.0)
    param1 = ot.Uniform(0.0, 1.0)
    param2 = ot.Uniform(0.0, 1.0)
    param3 = ot.Uniform(0.0, 1.0)
    param4 = ot.Uniform(0.0, 1.0)
    return ot.ComposedDistribution([param0, param1, param2, param3, param4])

melissa_study = melissa.Study()
melissa_study.set_option('username', USERNAME)
melissa_study.set_option('working_directory', WORKDIR)
melissa_study.set_option('sampling_size', 20) # initial number of parameter sets
melissa_study.set_option('nb_timesteps', 100) # number of timesteps, from Melissa point of view
melissa_study.set_option('field_names', ["heat1"]) # list of field names
melissa_study.set_option('simulation_timeout', 400) # simulations are restarted if no life sign for 400 seconds
melissa_study.set_option('checkpoint_interval', 300) # server checkpoints every 300 seconds
melissa_study.set_option('verbosity', 2) # verbosity: 0: only errors, 1: errors + warnings, 2: usefull infos (default), 3: debug info

print ('username:            ' + str(melissa_study.get_option('username')))
print ('working_directory:   ' + str(melissa_study.get_working_directory()))
print ('sampling_size:       ' + str(melissa_study.get_sampling_size()))
print ('nb_time_steps:       ' + str(melissa_study.get_nb_timesteps()))
print ('field_names:         ' + str(melissa_study.get_field_names()))
print ('simulation_timeout:  ' + str(melissa_study.get_simulation_timeout()))
print ('checkpoint_interval: ' + str(melissa_study.get_checkpoint_interval()))
print ('verbosity:           ' + str(melissa_study.get_verbosity()))

melissa_study.compute_mean()
melissa_study.compute_threshold_exceedances(0.7)
print ('threshold values:    ' +str(melissa_study.get_threshold_values()))
melissa_study.compute_quantiles([0.05,0.25,0.5,0.75,0.95])
print ('quantile values:     ' +str(melissa_study.get_quantile_values()))
melissa_study.compute_sobol_indices("MELISSA_COUPLING_MPI") # option for Sobol' simulation groups coupling

melissa_study.param_distribution(param_distribution)
melissa_study.launch_group(launch_group)
melissa_study.launch_server(launch_server)
melissa_study.check_server_job(check_job)
melissa_study.check_group_job(check_job)
melissa_study.restart_server(launch_server)
melissa_study.check_scheduler_load(check_load)
melissa_study.cancel_job(kill_job)

melissa_study.run()

